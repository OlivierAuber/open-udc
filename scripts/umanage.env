#!/bin/bash

function i { return ; } # Just because "<<" mess with syntax coloration ...

function udc_freadgrains {
# (fast) Print an array to tell how many (synchronized) grains are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st key in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which have been synchronized (validated) with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local key=${1:-${myaccounts[0]}} i=63 j

    [[ -d "$udcHOME/$Currency/k/$key" ]] || return 1
#    while ! [[ -f "$udcHOME/$Currency/k/$key/g/"$((1<<i )) ]] ; do # Note "<<" mess with syntax coloration ...
i 
        ((i--))
    done
    for ((j=0;j<=i;j++)) ; do
        echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$key/g/"$((1<<j)) 2> /dev/null) ))"
    done
}

function udc_freadwgrains {
# (fast) Print an array to tell how many grains (waiting to be synchronized) are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st key in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which synchronization have not been done/validated with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local key=${1:-${myaccounts[0]}} i=63 j

    [[ -d "$udcHOME/$Currency/k/$key" ]] || return 1
#    while ! [[ -f "$udcHOME/$Currency/k/$key/w/g/"$((1<< i )) ]] ; do # Note "<<" mess with syntax coloration ... 
i
        ((i--))
    done
    for ((j=0;j<=i;j++)) ; do
        echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$key/w/g/"$((1<<j)) 2> /dev/null) ))"
    done
}



function udc_freadbalance {
# (fast) Print sum (value) of grains usable in all given accounts according to local files
# Arguments 1... (Optionnal) : fingerprint of keys/accounts to read balance. By default : use keys in $myaccounts.
# Output 3 items :
#           - The amount which have been synchronized (validated) with some publication servers
#           - The amount which synchronization have not been done/validated with some publication servers
#           - The total 
# Return true if all OK. 1 if a given key in the (global variable) $Currency is not found locally.
local keys file vamount=0 ret=0

    for keys in ${@:-${myaccounts[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
        while read file ; do 
	    ((vamount+=${file##*/}*$(gawk 'END { print NR }' $file) ))
    	done < <(ls "$udcHOME/$Currency/k/$keys/g/"[1-9]*)
    done
    #echo -e "$vamount\n$wamount\n$((wamount+vamount))"
    echo -e "$((vamount))"

    return $ret
}

function udc_preparetransaction {
# Prepare grains for a transaction
# Argument 1 : amount
# Arguments 2 (Optionnal) : fingerprint of the key/account to use. By default : use 1st key in $myaccounts.
# Output and array to tell how many grains to take from each value
## Return the sum of the best grains selection : it can be greater than the amount asked, if we miss smallest grains. Or lesser if the amount asked is greater than the balance.
# Return 0 if prepared grains match asked amount. 254 if the amount asked is greater than the balance. Max(253,sum-asked) if we miss smallest grains. 255 if an other error occurs.

    local amount=$(($1)) key="${2:-${myaccounts[0]}}" i=0 j=0 total=0 sum=0 out=()

    (($1<=0)) || return 0 # if amount<=0 , nothing to do ...

    local wallet=($(udc_freadgrains $key))
    for i in ${!wallet[@]} ; do 
        ((total+=wallet[i]*(1<<i)))
    done

    ((total<amount)) && return 254 # We don't have enough grains !!

    mkdir -p "$TmpDir/$key/g"
    while (( (1<<i)<=amount )) ; do 
        ((i++))
    done
    for ((j=0;j<i;j++)) ; do
        ((total+=wallet[j]*(1<<j)))
        ((out[j]=0))
    done
    if ((total<amount)) ; then # We miss smallest grain for the exact amount
        for ((j=i;j<64;j++)) ; do
            ((out[j]=0))
            if ((wallet[j])) ; then 
                #cp "$udcHOME/$Currency/k/$key/g/"$((1<<j)) "$TmpDir/$key/g/" || return 255
                #grains=($(sed -n 1p "$TmpDir/$key/g/"$((1<<j)) )) || return 255
                #sed -i 1d "$TmpDir/$key/g/$ref" || return 255
                #echo "${grains[@]}"
                ((out[j]=1))
                echo "${out[@]}"
                return $(((1<<j)-amount>253?253:(1<<j)-amount))
            fi
        done
        return 255
    fi

    while ((sum<amount && i>=0)) ; do
        if ((wallet[i] && sum+(1<<i)<=amount)); then
            ((wallet[i]--))
            ((out[i]++))
            ((sum+=1<<i))
        else
            ((i--))
        fi
    done

    ((sum==amount)) || return 255

    echo "${out[@]}"
    return

    #for i in ${!out[@]} ; do 
        #cp "$udcHOME/$Currency/k/$key/g/$ref" "$TmpDir/$key/g/" || return 255
        #g+=($(sed -n 1,$((1<<j))p "$TmpDir/$key/g/$ref" )) || return 255
        #sed -i 1,$((1<<j))d "$TmpDir/$key/g/$ref" || return 255
}
