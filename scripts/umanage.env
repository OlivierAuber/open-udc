#!/bin/bash


function udc_freadvgrains {
# (fast) Print an array to tell how many grains are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st keys in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which have been synchronized (validated) with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local i=63 j ret=0

    for keys in ${@:-${mykeys[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
#        while ! [[ -f "$udcHOME/$Currency/k/$keys/v/g/$((1<<i))" ]] ; do # Note "<<" mess with syntax coloration ... 
            ((i--))
        done
        for ((j=0;j<=i;j++)) ; do
		    echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$keys/v/g/"$((1<<j)) 2> /dev/null) ))"
	    done
    done
    return $ret
}

function udc_freadwgrains {
# (fast) Print an array to tell how many grains are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st keys in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which synchronization have not been done/validated with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local i=63 j ret=0

    for keys in ${@:-${mykeys[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
#        while ! [[ -f "$udcHOME/$Currency/k/$keys/w/g/"$((1<<i)) ]] ; do # Note "<<" mess with syntax coloration ... 
            ((i--))
        done
        for ((j=0;j<=i;j++)) ; do
		    echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$keys/w/g/"$((1<<j)) 2> /dev/null) ))"
	    done
    done
    return $ret
}



function udc_freadbalance {
# (fast) Print sum (value) of grains usable in all given accounts according to local files
# Arguments 1... (Optionnal) : fingerprint of keys/accounts to read balance. By default : use keys in $mykeys.
# Output 3 lines :
#           - The amount which have been synchronized (validated) with some publication servers
#           - The amount which synchronization have not been done/validated with some publication servers
#           - The total 
# Return true if all OK. 1 if a given key in the (global variable) $Currency is not found locally.
local keys file wamount=0 vamount=0 ret=0

    for keys in ${@:-${mykeys[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
        while read file ; do 
	    ((vamount+=${file##*/}*$(gawk 'END { print NR }' $file) ))
    	done < <(ls "$udcHOME/$Currency/k/$keys/v/g/"[1-9]*)
        while read file ; do 
	    ((wamount+=${file##*/}*$(gawk 'END { print NR }' $file) ))
    	done < <(ls "$udcHOME/$Currency/k/$keys/w/g/"[1-9]*)
    done
    echo -e "$vamount\n$wamount\n$((wamount+vamount))"

    return $ret
}

function udc_preparetransaction {
# Prepare grains for a transaction
# Argument 1 : amount
# Arguments 2... (Optionnal) : fingerprint of keys/account to use. By default : use keys in $mykeys.
# Output the "best" list of grains to send.
## Return the sum of the best grains selection : it can be greater than the amount asked, if we miss smallest grains. Or lesser if the amount asked is greater than the balance.
# Return 0 if prepared grains match asked amount. 255 if the amount asked is greater than the balance. Max(254,sum-asked) if we miss smallest grains.

    local amount=$(($1)) ref=1 ret=0 g
    shift

    vwallet=($(udc_freadwvgrains ${@:-${mykeys[@]}}))
    wwallet=($(udc_freadwgrains ${@:-${mykeys[@]}}))
    while ((ref<=amount)) ; do
        if ((amount&ref)) ; then
            g=$(sed -n '1p' "$udcHOME/$Currency/k/$keys/v/g/$ref" )
            [[g=
        else 
            ((ret+=ref))
        fi
    done
    return $ret
}
