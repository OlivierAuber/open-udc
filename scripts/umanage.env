#!/bin/bash

function i { return ; } # Just because "<<" mess with syntax coloration ...

function udc_freadgrains {
# (fast) Print an array to tell how many grains are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st key in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local key=${1:-${myaccounts[0]}} i=63 j

    [[ -d "$udcHOME/$Currency/k/$key" ]] || return 1
#    while ! [[ -f "$udcHOME/$Currency/k/$key/g/"$((1<<i )) ]] ; do # Note "<<" mess with syntax coloration ...
i 
        ((i--))
    done
    for ((j=0;j<=i;j++)) ; do
        echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$key/g/"$((1<<j)) 2> /dev/null) )) "
    done
}

function udc_freadbalance {
# (fast) Print sum (value) of grains usable in all given accounts according to local files
# Arguments 1... (Optionnal) : fingerprint of keys/accounts to read balance. By default : use keys in $myaccounts.
# Output the total amount of grains available in all given accounts/key
# Return true if all OK. 1 if a given key in the (global variable) $Currency is not found locally.
local keys file vamount=0 ret=0

    for keys in ${@:-${myaccounts[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
        while read file ; do 
	    ((vamount+=${file##*/}*$(gawk 'END { print NR }' $file) ))
    	done < <(ls "$udcHOME/$Currency/k/$keys/g/"[1-9]*)
    done
    #echo -e "$vamount\n$wamount\n$((wamount+vamount))"
    echo -e "$((vamount))"

    return $ret
}

function udc_preparetransaction {
# Prepare grains for a transaction
# Argument 1 : amount
# Arguments 2 (Optionnal) : fingerprint of the key/account to use. By default : use 1st key in $myaccounts.
# Output and array to tell how many grains to take from each value
## Return the sum of the best grains selection : it can be greater than the amount asked, if we miss smallest grains. Or lesser if the amount asked is greater than the balance.
# Return 0 if prepared grains match asked amount. 254 if the amount asked is greater than the balance. Max(253,sum-asked) if we miss smallest grains. 255 if an other error occurs.

    local amount=$(($1)) key="${2:-${myaccounts[0]}}" i=0 j=0 total=0 sum=0 miss out=()

    ((amount>0)) || return 0 # if amount<=0 , nothing to do ...

    local wallet=($(udc_freadgrains $key))
    for ((i=0;i<${#wallet[@]};i++)) ; do 
        ((total+=wallet[i]*(1<<i)))
        ((out[i]=0))
        if (( (1<<i)<=amount )) ; then
            ((j=i+1))
        fi
    done
    #echo "total=$total"

    ((total<amount)) && return 254 # We don't have enough grains !!

    #mkdir -p "$TmpDir/$key/g"

    while ((sum!=amount && j>=0)) ; do
        if ((wallet[j] && sum+(1<<j)<=amount)); then
            ((wallet[j]--))
            ((out[j]++))
            ((sum+=1<<j))
        else
            ((j--))
        fi
    done
#    echo $sum

    if ((sum<amount)) ; then # we can't make the exact amount
        ((miss=amount-sum)) ; j=0
        while ((miss>>j)) ; do ((j++)) ; done
#        echo "$miss $j"
        for ((i=j;i<${#wallet[@]};i++)) ; do 
            if ((wallet[i])) ; then
                if (((1<<i)>amount)) ; then 
                    for j in ${!out[@]} ; do
                        ((out[j]=0))
                    done
                    ((out[i]=1))
                    ((sum=1<<i))
                else
                    # Note: It may be optimized, to remove smallest grains.
                    ((out[i]++))
                    ((sum+=1<<i))
                fi
                echo "${out[@]}"
                return $((sum-amount>253?253:sum-amount))
            fi
        done
        return 255
    elif ((sum>amount)) ; then
        return 255
    else
        echo "${out[@]}"
        return
    fi

    return 255

    #for i in ${!out[@]} ; do 
        #cp "$udcHOME/$Currency/k/$key/g/$ref" "$TmpDir/$key/g/" || return 255
        #g+=($(sed -n 1,$((1<<j))p "$TmpDir/$key/g/$ref" )) || return 255
        #sed -i 1,$((1<<j))d "$TmpDir/$key/g/$ref" || return 255
}

function udc_maketransaction {
# create the gpg message of a transaction
# Argument 1: the key/account which make the transaction
# Argument 2: the destination key/account of the transaction
# Argument 3... : the grains to send for each value, as given by udc_preparetransaction account.
# Return true if OK, 1 if fail.

    local srck="$1" destk="$2" g i=0 ok=0 grains="" srcn grain neg KeyID ntk

    [[ "$srck" =~ ^[0-9A-F]{40}$ ]] && [[ "$detk" =~ ^[0-9A-F]{40}$ ]] || return 1
    shift 2

    for g in "$@" ; do
        if ((g>0)) ; then
            ok=1
            grains+="$(sed -n "1,${g}p" "$udcHOME/$Currency/k/$key/g/"$((1<<i)) ) "
        fi
        ((i++))
    done
    ((ok)) || return 1

    srcn="$(ls -vr "$udcHOME/$Currency/k/$keys/w/" | sed -n '1p' )"
    [[ "$srcn" ]] || srcn="$(ls -vr "$udcHOME/$Currency/k/$keys/v/" | sed -n '1p' )"
    ((srcn++))

    (echo -e "d=t2\n$Currency\n$srcn\n$destk" ;
    while read grain neg KeyID ntk ; do

        echo "$grain $((neg+1)) $KeyID $ntk"
    done <(udc_db_getstatus $grains )
    # ...

    ) | $udc_gpg --sign -u "$srck!" > "$..." || return 1

    #publish the transaction
    #udc_POST ...

    #for g in ${grains[@]} ; do
    #    grep "${g%%\.*}" "$udcHOME/$Currency/k/$1/g/${g%%-*}" > /dev/null 2>&1 \
    #    || echo "$g" >> "$udcHOME/$Currency/k/$1/g/${g%%-*}"
    #done
}



