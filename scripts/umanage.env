#!/bin/bash

function i { return ; } # Just because "<<" mess with syntax coloration ...

function udc_freadgrains {
# (fast) Print an array to tell how many (synchronized) grains are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st key in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which have been synchronized (validated) with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local key=${1:-${myaccounts[0]}} i=63 j

    [[ -d "$udcHOME/$Currency/k/$key" ]] || return 1
    while ! [[ -f "$udcHOME/$Currency/k/$key/g/"$((1<<i )) ]] ; do # Note "<<" mess with syntax coloration ...
i 
        ((i--))
    done
    for ((j=0;j<=i;j++)) ; do
        echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$key/g/"$((1<<j)) 2> /dev/null) )) "
    done
}

function udc_freadwgrains {
# (fast) Print an array to tell how many grains (waiting to be synchronized) are available for each value.
# Arguments 1 (Optionnal) : fingerprint of the key/account to read grains. By default : use 1st key in $myaccounts.
# Output up to 64 numbers corresponding to the grains of value 1 2 4 8 16 ... 922337203685477580
#   which synchronization have not been done/validated with some publication servers
# Return true if all OK. 1 if the given key (in the global $Currency) is not found locally.
    local key=${1:-${myaccounts[0]}} i=63 j

    [[ -d "$udcHOME/$Currency/k/$key" ]] || return 1
#    while ! [[ -f "$udcHOME/$Currency/k/$key/w/g/"$((1<< i )) ]] ; do # Note "<<" mess with syntax coloration ... 
i
        ((i--))
 #   done
    for ((j=0;j<=i;j++)) ; do
        echo -n "$(($(gawk 'END { print NR }' "$udcHOME/$Currency/k/$key/w/g/"$((1<<j)) 2> /dev/null) ))"
    done
}



function udc_freadbalance {
# (fast) Print sum (value) of grains usable in all given accounts according to local files
# Arguments 1... (Optionnal) : fingerprint of keys/accounts to read balance. By default : use keys in $myaccounts.
# Output 3 items :
#           - The amount which have been synchronized (validated) with some publication servers
#           - The amount which synchronization have not been done/validated with some publication servers
#           - The total 
# Return true if all OK. 1 if a given key in the (global variable) $Currency is not found locally.
local keys file vamount=0 ret=0

    for keys in ${@:-${myaccounts[@]}} ; do
        if ! [[ -d "$udcHOME/$Currency/k/$keys" ]] ; then 
            ret=1
            continue
        fi
        while read file ; do 
	    ((vamount+=${file##*/}*$(gawk 'END { print NR }' $file) ))
    	done < <(ls "$udcHOME/$Currency/k/$keys/g/"[1-9]*)
    done
    #echo -e "$vamount\n$wamount\n$((wamount+vamount))"
    echo -e "$((vamount))"

    return $ret
}

function udc_preparetransaction {
# Prepare grains for a transaction
# Argument 1 : amount
# Arguments 2 (Optionnal) : fingerprint of the key/account to use. By default : use 1st key in $myaccounts.
# Output and array to tell how many grains to take from each value
## Return the sum of the best grains selection : it can be greater than the amount asked, if we miss smallest grains. Or lesser if the amount asked is greater than the balance.
# Return 0 if prepared grains match asked amount. 254 if the amount asked is greater than the balance. Max(253,sum-asked) if we miss smallest grains. 255 if an other error occurs.

    local amount=$(($1)) key="${2:-${myaccounts[0]}}" i=0 j=0 total=0 sum=0 miss out=()

    ((amount>0)) || return 0 # if amount<=0 , nothing to do ...

    local wallet=($(udc_freadgrains $key))
    for ((i=0;i<${#wallet[@]};i++)) ; do 
        ((total+=wallet[i]*(1<<i)))
        ((out[i]=0))
        if (( (1<<i)<=amount )) ; then
            ((j=i+1))
        fi
    done
    #echo "total=$total"

    ((total<amount)) && return 254 # We don't have enough grains !!

    #mkdir -p "$TmpDir/$key/g"

    while ((sum!=amount && j>=0)) ; do
        if ((wallet[j] && sum+(1<<j)<=amount)); then
            ((wallet[j]--))
            ((out[j]++))
            ((sum+=1<<j))
        else
            ((j--))
        fi
    done
#    echo $sum

    if ((sum<amount)) ; then # we can't make the exact amount
        ((miss=amount-sum)) ; j=0
        while ((miss>>j)) ; do ((j++)) ; done
#        echo "$miss $j"
        for ((i=j;i<${#wallet[@]};i++)) ; do 
            if ((wallet[i])) ; then
                if (((1<<i)>amount)) ; then 
                    for j in ${!out[@]} ; do
                        ((out[j]=0))
                    done
                    ((out[i]=1))
                    ((sum=1<<i))
                else
                    # Note: It may be optimized, to remove smallest grains.
                    ((out[i]++))
                    ((sum+=1<<i))
                fi
                echo "${out[@]}"
                return $((sum-amount>253?253:sum-amount))
            fi
        done
        return 255
    elif ((sum>amount)) ; then
        return 255
    else
        echo "${out[@]}"
        return
    fi

    return 255

    #for i in ${!out[@]} ; do 
        #cp "$udcHOME/$Currency/k/$key/g/$ref" "$TmpDir/$key/g/" || return 255
        #g+=($(sed -n 1,$((1<<j))p "$TmpDir/$key/g/$ref" )) || return 255
        #sed -i 1,$((1<<j))d "$TmpDir/$key/g/$ref" || return 255
}
